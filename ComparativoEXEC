"""
Experimento de comparação entre:
  • edit_distance_memo   – implementação top-down recursiva com memoização
  • edit_distance_bottom_up – implementação bottom-up iterativa

Requisitos:
  pip install matplotlib
"""

import random
import string
import sys
import time
import matplotlib.pyplot as plt


# ---------------------------------------------------------------------------
# 1) Algoritmo top-down recursivo com memoização
# ---------------------------------------------------------------------------
def edit_distance_memo(x: str, y: str) -> int:
    m, n = len(x), len(y)

    # tabela de memoização: (m+1) × (n+1)
    ed = [[-1] * (n + 1) for _ in range(m + 1)]

    # casos-base (primeira linha e primeira coluna)
    for i in range(m + 1):
        ed[i][0] = i
    for j in range(n + 1):
        ed[0][j] = j

    # aumenta o limite de recursão para evitar erro em n grandes
    sys.setrecursionlimit(max(10_000, 2 * (m + n)))

    # função recursiva interna
    def rec(i: int, j: int) -> int:
        if ed[i][j] >= 0:
            return ed[i][j]

        cost = 0 if x[i - 1] == y[j - 1] else 1
        ed[i][j] = min(
            rec(i - 1, j - 1) + cost,  # diagonal (match/substituição)
            rec(i - 1, j) + 1,         # cima    (remoção)
            rec(i, j - 1) + 1          # esquerda(inserção)
        )
        return ed[i][j]

    return rec(m, n)


# ---------------------------------------------------------------------------
# 2) Algoritmo bottom-up iterativo
# ---------------------------------------------------------------------------
def edit_distance_bottom_up(x: str, y: str) -> int:
    m, n = len(x), len(y)

    # matriz (m+1) × (n+1)
    ed = [[0] * (n + 1) for _ in range(m + 1)]

    # inicialização das bordas
    for i in range(m + 1):
        ed[i][0] = i
    for j in range(n + 1):
        ed[0][j] = j

    # preenchimento da tabela
    for i in range(1, m + 1):
        xi = x[i - 1]          # evita x[i-1] a cada iteração interna
        row_i = ed[i]          # linha atual
        row_prev = ed[i - 1]   # linha de cima
        for j in range(1, n + 1):
            cost = 0 if xi == y[j - 1] else 1
            diag = row_prev[j - 1] + cost
            up   = row_prev[j] + 1
            left = row_i[j - 1] + 1
            # atribui o mínimo das três possibilidades
            row_i[j] = diag if diag <= up and diag <= left else (left if left <= up else up)

    return ed[m][n]


# ---------------------------------------------------------------------------
# 3) Parâmetros do experimento (ajuste-os à vontade)
# ---------------------------------------------------------------------------
MIN_N, MAX_N = 10, 300          # intervalo de tamanhos das strings
K_RANGE       = (30, 50)        # nº de tamanhos distintos (reduzido p/ rodar rápido on-line)
M_RANGE       = (5, 8)          # nº de instâncias por tamanho (idem)
ALPHABET      = string.ascii_lowercase


def main() -> None:
    random.seed(1)

    # define k e m de forma aleatória dentro dos intervalos
    k = random.randint(*K_RANGE)
    m = random.randint(*M_RANGE)

    # tamanhos igualmente espaçados
    step = (MAX_N - MIN_N) / (k - 1)
    sizes = [int(MIN_N + i * step) for i in range(k)]

    time_memo   = []
    time_bottom = []

    for n in sizes:
        total_memo   = 0.0
        total_bottom = 0.0

        for _ in range(m):
            s1 = ''.join(random.choices(ALPHABET, k=n))
            s2 = ''.join(random.choices(ALPHABET, k=n))

            # --- top-down ---
            start = time.perf_counter()
            d1 = edit_distance_memo(s1, s2)
            total_memo += time.perf_counter() - start

            # --- bottom-up ---
            start = time.perf_counter()
            d2 = edit_distance_bottom_up(s1, s2)
            total_bottom += time.perf_counter() - start

            # verificação de correção
            assert d1 == d2, f"Distâncias diferentes em n={n}"

        time_memo.append(total_memo / m)
        time_bottom.append(total_bottom / m)

    # -----------------------------------------------------------------------
    # 4) Plotagem dos resultados
    # -----------------------------------------------------------------------
    plt.figure(figsize=(8, 5))
    plt.plot(sizes, time_memo,   label="Top-down memoização")
    plt.plot(sizes, time_bottom, label="Bottom-up iterativo")
    plt.xlabel("Tamanho da entrada (n)")
    plt.ylabel("Tempo médio por instância (s)")
    plt.title(f"Comparação de tempo – k={k}, m={m}")
    plt.legend()
    plt.tight_layout()
    plt.show()


if __name__ == "__main__":
    main()
